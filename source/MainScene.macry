import Audio;
import Graphics2D;
import Graphics2DText;
import Math;
import Random;
import TwoCansAlpha4;

const X_RES = $var["screen_width"];
const Y_RES = $var["screen_height"];

const ONE_THIRD_TAU = 2.0 * Math.PI / 3.0;
const TWO_THIRDS_TAU = 2.0 * ONE_THIRD_TAU;

const FONT_SIZE = 16;

const LATERAL_ACCELERATION = 0.01;
const LATERAL_DRAG = 0.9;
const LONGITUDINAL_SPEED = 0.01;

const MIN_X = -1.0;
const MAX_X = 1.0;
const MIN_Y = -1.0;
const MAX_Y = 1.0;
const MIN_Z = 1.0;
const MAX_Z = 10.0;

const SHIP_HALF_WIDTH = 0.2;
const SHIP_HALF_HEIGHT = 0.1;
const SHIP_LENGTH = 0.4;
const TILT_FACTOR = 3.0;

const SHIP_MIN_X = -1.0 + SHIP_HALF_WIDTH;
const SHIP_MAX_X = 1.0 - SHIP_HALF_WIDTH;
const SHIP_MIN_Y = -1.0 + SHIP_HALF_HEIGHT;
const SHIP_MAX_Y = 1.0 - SHIP_HALF_HEIGHT;

const LASER_LENGTH = 0.4;
const LASER_SPEED = 0.3;
const LASER_COOLDOWN = 15;

const ENEMY_RADIUS = 0.2;
const ENEMY_HALF_LENGTH = 0.2;
const ENEMY_SPEED = 0.05;
const ENEMY_MIN_X = -1.0 + ENEMY_RADIUS;
const ENEMY_MAX_X = 1.0 - ENEMY_RADIUS;
const ENEMY_MIN_Y = -1.0 + ENEMY_RADIUS;
const ENEMY_MAX_Y = 1.0 - ENEMY_RADIUS;
const ENEMY_MAX_OMEGA = 0.3;

const SPAWN_MAX_COOLDOWN = 5 * LASER_COOLDOWN;
const SPAWN_MIN_COOLDOWN = LASER_COOLDOWN;
const SPAWN_COOLDOWN_REDUCTION_FREQUENCY = 200;

const DEBRIS_RADIUS = 0.1;
const DEBRIS_COUNT = 10;
const DEBRIS_MAX_OMEGA = 0.6;
const DEBRIS_MAX_COMPONENT_SPEED = 0.02;
const DEBRIS_MIN_LIFETIME = 10;
const DEBRIS_MAX_LIFETIME = 30;

const HUD_TOP_PAD = 5.0;
const MAX_LIVES = 3;
const HEART_LEFT_PAD = 5.0;

class Enemy {
	field pos;
	field omega;

	constructor(pos, omega) {
		this.pos = pos;
		this.omega = omega;
	}
}

class Debris {
	field pos;
	field vel;
	field omega;
	field lifetime;

	constructor(pos, vel, omega, lifetime) {
		this.pos = pos;
		this.vel = vel;
		this.omega = omega;
		this.lifetime = lifetime;
	}
}

class MainScene : AbstractScene {
	static field farTopLeft = ## project # [-1.0, 1.0, MAX_Z] ##;
	static field farTopRight = ## project # [1.0, 1.0, MAX_Z] ##;
	static field farBottomLeft = ## project # [-1.0, -1.0, MAX_Z] ##;
	static field farBottomRight = ## project # [1.0, -1.0, MAX_Z] ##;

	static field font = FontResource.fromResource("Infinium Guardian.ttf").getRenderer().setSize(FONT_SIZE).setColor(0, 192, 0);
	static field laserSound = Audio.SoundResource.loadFromResource("laser.ogg");
	static field explosionSound1 = Audio.SoundResource.loadFromResource("explosion1.ogg");
	static field explosionSound2 = Audio.SoundResource.loadFromResource("explosion2.ogg");
	static field spawnSound1 = Audio.SoundResource.loadFromResource("spawn1.ogg");
	static field spawnSound2 = Audio.SoundResource.loadFromResource("spawn2.ogg");

	static field heart = Images.get("heart.png");

	field time = 0;

	field pos = [0.0, -0.5, MIN_Z];
	field vel = [0.0, 0.0];

	field laserActiveCooldown = 0;
	field lasers = [];

	field spawnCooldown = SPAWN_MAX_COOLDOWN;
	field spawnActiveCooldown = SPAWN_MAX_COOLDOWN;
	field oddSpawn = true;
	field enemies = [];

	field debris = [];

	field score = 0;
	field scoreText = MainScene.font.render("0");

	field lives = MAX_LIVES;

	function spawnDebris(center) {
		for (i = 0; i < DEBRIS_COUNT; ++i) {
			this.debris.add(new Debris
				( center.clone()
				, [ DEBRIS_MAX_COMPONENT_SPEED * (1 - 2.0 * Random.randomFloat())
				  , DEBRIS_MAX_COMPONENT_SPEED * (1 - 2.0 * Random.randomFloat())
				  , DEBRIS_MAX_COMPONENT_SPEED * (1 - 2.0 * Random.randomFloat())
				  ]
				, DEBRIS_MAX_OMEGA * (1.0 - 2.0 * Random.randomFloat())
				, Random.randomInt(DEBRIS_MIN_LIFETIME, DEBRIS_MAX_LIFETIME + 1)
				));
		}
	}

	function update(inputManager, events) {
		++this.time;
		if (this.lives > 0) {
			// Move.
			if (inputManager.isKeyPressed(KeyboardKey.RIGHT)) {
				this.vel[0] += LATERAL_ACCELERATION;
			}
			if (inputManager.isKeyPressed(KeyboardKey.LEFT)) {
				this.vel[0] -= LATERAL_ACCELERATION;
			}
			if (inputManager.isKeyPressed(KeyboardKey.UP)) {
				this.vel[1] += LATERAL_ACCELERATION;
			}
			if (inputManager.isKeyPressed(KeyboardKey.DOWN)) {
				this.vel[1] -= LATERAL_ACCELERATION;
			}
			// Update position according to velocity.
			this.pos[0] += this.vel[0];
			this.pos[1] += this.vel[1];
			// Apply drag.
			this.vel[0] *= LATERAL_DRAG;
			this.vel[1] *= LATERAL_DRAG;
			// Keep the ship in bounds.
			if (this.pos[0] < SHIP_MIN_X) {
				this.pos[0] = SHIP_MIN_X;
				this.vel[0] = 0.0;
			} else if (this.pos[0] > SHIP_MAX_X) {
				this.pos[0] = SHIP_MAX_X;
				this.vel[0] = 0.0;
			}
			if (this.pos[1] < SHIP_MIN_Y) {
				this.pos[1] = SHIP_MIN_Y;
				this.vel[1] = 0.0;
			} else if (this.pos[1] > SHIP_MAX_Y) {
				this.pos[1] = SHIP_MAX_Y;
				this.vel[1] = 0.0;
			}
			// Shoot lasers.
			if (this.laserActiveCooldown > 0) {
				--this.laserActiveCooldown;
			}
			if (this.laserActiveCooldown == 0 && inputManager.isKeyPressed(KeyboardKey.SPACE)) {
				MainScene.laserSound.play();
				this.lasers.add([this.pos[0] - SHIP_HALF_WIDTH, this.pos[1], this.pos[2]]);
				this.lasers.add([this.pos[0] + SHIP_HALF_WIDTH, this.pos[1], this.pos[2]]);
				this.laserActiveCooldown = LASER_COOLDOWN;
			}
		}
		// Update laser positions.
		for (i = 0; i < this.lasers.length; ++i) {
			this.lasers[i][2] += LASER_SPEED;
			if (this.lasers[i][2] > MAX_Z) {
				this.lasers.remove(i);
				--i;
			}
		}
		// Update enemy positions.
		for (i = 0; i < this.enemies.length; ++i) {
			this.enemies[i].pos[2] -= ENEMY_SPEED;
			// Check if enemy has reached the end.
			if (this.enemies[i].pos[2] < MIN_Z) {
				// Play sound.
				sound = MainScene.explosionSound2.play();
				// Spawn debris.
				this.spawnDebris(this.enemies[i].pos);
				// Destroy the enemy.
				this.enemies.remove(i);
				--i;
				// Lose a life.
				--this.lives;
				if (this.lives == 0) {
					// Game over.
				}
			}
		}
		// Update debris.
		for (i = 0; i < this.debris.length; ++i) {
			debris = this.debris[i];
			--debris.lifetime;
			if (debris.lifetime == 0) {
				this.debris.remove(i);
				--i;
				continue;
			}
			debris.pos[0] += debris.vel[0];
			debris.pos[1] += debris.vel[1];
			debris.pos[2] += debris.vel[2];
		}
		// Spawn enemies.
		if (this.spawnCooldown > SPAWN_MIN_COOLDOWN && this.time % SPAWN_COOLDOWN_REDUCTION_FREQUENCY == 0) {
			--this.spawnCooldown;
		}
		if (this.spawnActiveCooldown > 0) {
			--this.spawnActiveCooldown;
		}
		if (this.spawnActiveCooldown == 0) {
			if (this.oddSpawn) {
				MainScene.spawnSound1.play();
			} else {
				MainScene.spawnSound2.play();
			}
			this.oddSpawn = !this.oddSpawn;
			pos =
				[ ENEMY_MIN_X + Random.randomFloat() * (ENEMY_MAX_X - ENEMY_MIN_X)
				, ENEMY_MIN_Y + Random.randomFloat() * (ENEMY_MAX_Y - ENEMY_MIN_Y)
				, MAX_Z
				];
			this.enemies.add(new Enemy(pos, ENEMY_MAX_OMEGA * (1.0 - 2.0 * Random.randomFloat())));
			this.spawnActiveCooldown = this.spawnCooldown;
		}
		// Check for laser collisions.
		for (laserIdx = 0; laserIdx < this.lasers.length; ++laserIdx) {
			for (enemyIdx = 0; enemyIdx < this.enemies.length; ++enemyIdx) {
				laserPos = this.lasers[laserIdx];
				enemy = this.enemies[enemyIdx];
				hit = enemy.pos[0] - ENEMY_RADIUS <= laserPos[0]
					&& laserPos[0] <= enemy.pos[0] + ENEMY_RADIUS
					&& enemy.pos[1] - ENEMY_RADIUS <= laserPos[1]
					&& laserPos[1] <= enemy.pos[1] + ENEMY_RADIUS
					&& enemy.pos[2] - ENEMY_RADIUS <= laserPos[2] + LASER_LENGTH
					&& laserPos[2] <= enemy.pos[2] + ENEMY_RADIUS;
				if (hit) {
					// Play sound.
					sound = MainScene.explosionSound1.play();
					// Spawn debris.
					this.spawnDebris(enemy.pos);
					// Update score.
					if (this.lives > 0) {
						++this.score;
						this.scoreText = MainScene.font.render(this.score);
					}
					// Destroy the enemy and the laser.
					this.lasers.remove(laserIdx);
					this.enemies.remove(enemyIdx);
					--laserIdx;
					--enemyIdx;
					break;
				}
			}
		}
	}

	function render() {
		Graphics2D.Draw.fill(0, 0, 0);

		// Draw spaceship.
		if (this.lives > 0) {
			left = ## project # [this.pos[0] - SHIP_HALF_WIDTH, this.pos[1], this.pos[2]] ##;
			right = ## project # [this.pos[0] + SHIP_HALF_WIDTH, this.pos[1], this.pos[2]] ##;
			top = ## project # [this.pos[0], this.pos[1] + SHIP_HALF_HEIGHT, this.pos[2]] ##;
			bottom = ## project # [this.pos[0], this.pos[1] - SHIP_HALF_HEIGHT, this.pos[2]] ##;
			front = ## project #
				[ this.pos[0] + TILT_FACTOR * this.vel[0]
				, this.pos[1] + TILT_FACTOR * this.vel[1]
				, this.pos[2] + SHIP_LENGTH
				] ##;
			## drawLine # left # top ##;
			## drawLine # top # right ##;
			## drawLine # right # bottom ##;
			## drawLine # bottom # left ##;
			## drawLine # left # front ##;
			## drawLine # right # front ##;
			## drawLine # top # front ##;
			## drawLine # bottom # front ##;
		}

		// Draw lasers.
		for (pos : this.lasers) {
			start = ## project # pos ##;
			end = ## project # [pos[0], pos[1], pos[2] + LASER_LENGTH] ##;
			## drawLine # start # end ##;
		}

		// Draw enemies.
		for (enemy : this.enemies) {
			pos = enemy.pos;
			theta = this.time * enemy.omega;
			cosT = Math.cos(theta);
			sinT = Math.sin(theta);
			cosT90 = Math.cos(theta + 0.5 * Math.PI);
			sinT90 = Math.sin(theta + 0.5 * Math.PI);
			left = ## project # [pos[0] - ENEMY_RADIUS * cosT, pos[1] - ENEMY_RADIUS * sinT, pos[2]] ##;
			right = ## project # [pos[0] + ENEMY_RADIUS * cosT, pos[1] + ENEMY_RADIUS * sinT, pos[2]] ##;
			top = ## project # [pos[0] + ENEMY_RADIUS * cosT90, pos[1] + ENEMY_RADIUS * sinT90, pos[2]] ##;
			bottom = ## project # [pos[0] - ENEMY_RADIUS * cosT90, pos[1] - ENEMY_RADIUS * sinT90, pos[2]] ##;
			front = ## project # [pos[0], pos[1], pos[2] - ENEMY_HALF_LENGTH] ##;
			back = ## project # [pos[0], pos[1], pos[2] + ENEMY_HALF_LENGTH] ##;
			## drawLine # left # top ##;
			## drawLine # top # right ##;
			## drawLine # right # bottom ##;
			## drawLine # bottom # left ##;
			## drawLine # left # front ##;
			## drawLine # top # front ##;
			## drawLine # right # front ##;
			## drawLine # bottom # front ##;
			## drawLine # left # back ##;
			## drawLine # top # back ##;
			## drawLine # right # back ##;
			## drawLine # bottom # back ##;
		}

		// Draw debris.
		for (debris : this.debris) {
			pos = debris.pos;
			theta = this.time * debris.omega;
			radius = DEBRIS_RADIUS * debris.lifetime / DEBRIS_MAX_LIFETIME;
			right = ## project #
				[ pos[0] + radius * Math.cos(theta)
				, pos[1] + radius * Math.sin(theta)
				, pos[2]
				] ##;
			topLeft = ## project #
				[ pos[0] + radius * Math.cos(theta + ONE_THIRD_TAU)
				, pos[1] + radius * Math.sin(theta + ONE_THIRD_TAU)
				, pos[2]
				] ##;
			bottomLeft = ## project #
				[ pos[0] + radius * Math.cos(theta + TWO_THIRDS_TAU)
				, pos[1] + radius * Math.sin(theta + TWO_THIRDS_TAU)
				, pos[2]
				] ##;
			## drawLine # right # topLeft ##;
			## drawLine # topLeft # bottomLeft ##;
			## drawLine # bottomLeft # right ##;
		}

		// Draw box around world.
		## drawLine # [0.0, 0.0] # MainScene.farTopLeft ##;
		## drawLine # [X_RES, 0.0] # MainScene.farTopRight ##;
		## drawLine # [0.0, Y_RES] # MainScene.farBottomLeft ##;
		## drawLine # [X_RES, Y_RES] # MainScene.farBottomRight ##;
		## drawLine # MainScene.farTopLeft # MainScene.farTopRight ##;
		## drawLine # MainScene.farTopRight # MainScene.farBottomRight ##;
		## drawLine # MainScene.farBottomRight # MainScene.farBottomLeft ##;
		## drawLine # MainScene.farBottomLeft # MainScene.farTopLeft ##;

		// Draw score.
		this.scoreText.draw(0.5 * X_RES - this.scoreText.width, HUD_TOP_PAD);

		// Draw lives.
		for (i = 0; i < this.lives; ++i) {
			MainScene.heart.draw
				( 0.5 * X_RES + HEART_LEFT_PAD + i * (HEART_LEFT_PAD + MainScene.heart.width)
				, HUD_TOP_PAD
				);
		}
	}
}
