import Audio;
import Graphics2D;
import Graphics2DText;
import Math;
import Random;
import TwoCansAlpha4;

class Enemy {
	field pos;
	field omega;

	constructor(pos, omega) {
		this.pos = pos;
		this.omega = omega;
	}
}

class Debris {
	field pos;
	field vel;
	field omega;
	field lifetime;

	constructor(pos, vel, omega, lifetime) {
		this.pos = pos;
		this.vel = vel;
		this.omega = omega;
		this.lifetime = lifetime;
	}
}

class MainScene : AbstractScene {
	static field farTopLeft = ## project # [-1.0, 1.0, MAX_Z] ##;
	static field farTopRight = ## project # [1.0, 1.0, MAX_Z] ##;
	static field farBottomLeft = ## project # [-1.0, -1.0, MAX_Z] ##;
	static field farBottomRight = ## project # [1.0, -1.0, MAX_Z] ##;

	static field font = FontResource.fromResource("Infinium Guardian.ttf").getRenderer()
		.setSize(FONT_SIZE)
		.setColor(0, 192, 0);
	static field titleText = MainScene.font.render("Eigenspace Invaders");

	static field laserSound = Audio.SoundResource.loadFromResource("laser.ogg");
	static field explosionSound1 = Audio.SoundResource.loadFromResource("explosion1.ogg");
	static field explosionSound2 = Audio.SoundResource.loadFromResource("explosion2.ogg");
	static field spawnSound1 = Audio.SoundResource.loadFromResource("spawn1.ogg");
	static field spawnSound2 = Audio.SoundResource.loadFromResource("spawn2.ogg");
	static field gameOverSound = Audio.SoundResource.loadFromResource("game-over.ogg");

	static field heart = Images.get("heart.png");
	static field movementHelp = Images.get("arrows.png");

	field state = MOVEMENT_HELP_STATE;
	field timeInState = 0;

	field pos = [0.0, -0.5, MIN_Z];
	field vel = [0.0, 0.0];

	field laserActiveCooldown = 0;
	field lasers = [];

	field spawnCooldown = SPAWN_MAX_COOLDOWN;
	field spawnActiveCooldown = SPAWN_MAX_COOLDOWN;
	field oddSpawn = true;
	field enemies = [];

	field debris = [];

	field score = 0;
	field scoreText = MainScene.font.render("0");

	field lives = MAX_LIVES;

	function setState(state) {
		this.state = state;
		this.timeInState = 0;
	}
	function spawnDebris(center) {
		for (i = 0; i < DEBRIS_COUNT; ++i) {
			this.debris.add(new Debris
				( center.clone()
				, [ DEBRIS_MAX_COMPONENT_SPEED * (1 - 2.0 * Random.randomFloat())
				  , DEBRIS_MAX_COMPONENT_SPEED * (1 - 2.0 * Random.randomFloat())
				  , DEBRIS_MAX_COMPONENT_SPEED * (1 - 2.0 * Random.randomFloat())
				  ]
				, DEBRIS_MAX_OMEGA * (1.0 - 2.0 * Random.randomFloat())
				, Random.randomInt(DEBRIS_MIN_LIFETIME, DEBRIS_MAX_LIFETIME + 1)
				));
		}
	}

	function updateShip(inputManager) {
		// Move.
		if (inputManager.isKeyPressed(KeyboardKey.RIGHT)) {
			this.vel[0] += LATERAL_ACCELERATION;
		}
		if (inputManager.isKeyPressed(KeyboardKey.LEFT)) {
			this.vel[0] -= LATERAL_ACCELERATION;
		}
		if (inputManager.isKeyPressed(KeyboardKey.UP)) {
			this.vel[1] += LATERAL_ACCELERATION;
		}
		if (inputManager.isKeyPressed(KeyboardKey.DOWN)) {
			this.vel[1] -= LATERAL_ACCELERATION;
		}
		// Update position according to velocity.
		this.pos[0] += this.vel[0];
		this.pos[1] += this.vel[1];
		// Apply drag.
		this.vel[0] *= LATERAL_DRAG;
		this.vel[1] *= LATERAL_DRAG;
		// Keep the ship in bounds.
		if (this.pos[0] < SHIP_MIN_X) {
			this.pos[0] = SHIP_MIN_X;
			this.vel[0] = 0.0;
		} else if (this.pos[0] > SHIP_MAX_X) {
			this.pos[0] = SHIP_MAX_X;
			this.vel[0] = 0.0;
		}
		if (this.pos[1] < SHIP_MIN_Y) {
			this.pos[1] = SHIP_MIN_Y;
			this.vel[1] = 0.0;
		} else if (this.pos[1] > SHIP_MAX_Y) {
			this.pos[1] = SHIP_MAX_Y;
			this.vel[1] = 0.0;
		}
		// Shoot lasers.
		if (this.laserActiveCooldown > 0) {
			--this.laserActiveCooldown;
		}
		if (this.laserActiveCooldown == 0 && inputManager.isKeyPressed(KeyboardKey.SPACE)) {
			MainScene.laserSound.play();
			this.lasers.add([this.pos[0] - SHIP_HALF_WIDTH, this.pos[1], this.pos[2]]);
			this.lasers.add([this.pos[0] + SHIP_HALF_WIDTH, this.pos[1], this.pos[2]]);
			this.laserActiveCooldown = LASER_COOLDOWN;
		}
	}

	function updatePhysics() {
		// Update laser positions.
		for (i = 0; i < this.lasers.length; ++i) {
			this.lasers[i][2] += LASER_SPEED;
			if (this.lasers[i][2] > MAX_Z) {
				this.lasers.remove(i);
				--i;
			}
		}
		// Update enemy positions.
		for (i = 0; i < this.enemies.length; ++i) {
			this.enemies[i].pos[2] -= ENEMY_SPEED;
			// Check if enemy has reached the end.
			if (this.enemies[i].pos[2] < MIN_Z) {
				// Play bad explosion sound.
				sound = MainScene.explosionSound2.play();
				// Spawn debris.
				this.spawnDebris(this.enemies[i].pos);
				// Destroy the enemy.
				this.enemies.remove(i);
				--i;
				// Lose a life.
				--this.lives;
				// Game over if out of lives during playing state.
				if (this.state == PLAYING_STATE && this.lives == 0) {
					this.setState(GAME_OVER_STATE);
					// Play game over sound.
					MainScene.gameOverSound.play();
					// Spawn debris.
					this.spawnDebris(this.pos);
				}
			}
		}
		// Update debris.
		for (i = 0; i < this.debris.length; ++i) {
			debris = this.debris[i];
			--debris.lifetime;
			if (debris.lifetime == 0) {
				this.debris.remove(i);
				--i;
				continue;
			}
			debris.pos[0] += debris.vel[0];
			debris.pos[1] += debris.vel[1];
			debris.pos[2] += debris.vel[2];
		}
		// Check for laser collisions.
		for (laserIdx = 0; laserIdx < this.lasers.length; ++laserIdx) {
			for (enemyIdx = 0; enemyIdx < this.enemies.length; ++enemyIdx) {
				laserPos = this.lasers[laserIdx];
				enemy = this.enemies[enemyIdx];
				hit = enemy.pos[0] - ENEMY_RADIUS <= laserPos[0]
					&& laserPos[0] <= enemy.pos[0] + ENEMY_RADIUS
					&& enemy.pos[1] - ENEMY_RADIUS <= laserPos[1]
					&& laserPos[1] <= enemy.pos[1] + ENEMY_RADIUS
					&& enemy.pos[2] - ENEMY_RADIUS <= laserPos[2] + LASER_LENGTH
					&& laserPos[2] <= enemy.pos[2] + ENEMY_RADIUS;
				if (hit) {
					// Play good explosion sound.
					sound = MainScene.explosionSound1.play();
					// Spawn debris.
					this.spawnDebris(enemy.pos);
					// Update score if in playing state.
					if (this.state == PLAYING_STATE) {
						++this.score;
						this.scoreText = MainScene.font.render(this.score);
					}
					// Destroy the enemy and the laser.
					this.lasers.remove(laserIdx);
					this.enemies.remove(enemyIdx);
					--laserIdx;
					--enemyIdx;
					break;
				}
			}
		}
	}

	function updateEnemySpawning() {
		// Reduce spawn cooldown periodically.
		if (this.spawnCooldown > SPAWN_MIN_COOLDOWN && this.timeInState % SPAWN_COOLDOWN_REDUCTION_FREQUENCY == 0) {
			--this.spawnCooldown;
		}
		// Reduce active spawn cooldown.
		if (this.spawnActiveCooldown > 0) {
			--this.spawnActiveCooldown;
		}
		// Spawn an enemy if not on cooldown.
		if (this.spawnActiveCooldown == 0) {
			if (this.oddSpawn) {
				MainScene.spawnSound1.play();
			} else {
				MainScene.spawnSound2.play();
			}
			this.oddSpawn = !this.oddSpawn;
			pos =
				[ ENEMY_MIN_X + Random.randomFloat() * (ENEMY_MAX_X - ENEMY_MIN_X)
				, ENEMY_MIN_Y + Random.randomFloat() * (ENEMY_MAX_Y - ENEMY_MIN_Y)
				, MAX_Z
				];
			this.enemies.add(new Enemy(pos, ENEMY_MAX_OMEGA * (1.0 - 2.0 * Random.randomFloat())));
			this.spawnActiveCooldown = this.spawnCooldown;
		}
	}

	function update(inputManager, events) {
		++this.timeInState;
		switch (this.state) {
			case MOVEMENT_HELP_STATE:
				this.updateShip(inputManager);
				arrowKeyPressed = inputManager.isKeyPressed(KeyboardKey.RIGHT)
					|| inputManager.isKeyPressed(KeyboardKey.LEFT)
					|| inputManager.isKeyPressed(KeyboardKey.UP)
					|| inputManager.isKeyPressed(KeyboardKey.DOWN);
				if (arrowKeyPressed) {
					Music.loadFromResource("title.ogg").play(false);
					this.setState(TITLE_STATE);
				}
				break;
			case TITLE_STATE:
				this.updateShip(inputManager);
				if (this.timeInState >= TITLE_STATE_DURATION) {
					this.setState(PLAYING_STATE);
				}
				break;
			case PLAYING_STATE:
				this.updateShip(inputManager);
				this.updateEnemySpawning();
				break;
			case GAME_OVER_STATE:
				break;
		}
		this.updatePhysics();
	}

	function drawShip() {
		left = ## project # [this.pos[0] - SHIP_HALF_WIDTH, this.pos[1], this.pos[2]] ##;
		right = ## project # [this.pos[0] + SHIP_HALF_WIDTH, this.pos[1], this.pos[2]] ##;
		top = ## project # [this.pos[0], this.pos[1] + SHIP_HALF_HEIGHT, this.pos[2]] ##;
		bottom = ## project # [this.pos[0], this.pos[1] - SHIP_HALF_HEIGHT, this.pos[2]] ##;
		front = ## project #
			[ this.pos[0] + TILT_FACTOR * this.vel[0]
			, this.pos[1] + TILT_FACTOR * this.vel[1]
			, this.pos[2] + SHIP_LENGTH
			] ##;
		## drawLine # left # top ##;
		## drawLine # top # right ##;
		## drawLine # right # bottom ##;
		## drawLine # bottom # left ##;
		## drawLine # left # front ##;
		## drawLine # right # front ##;
		## drawLine # top # front ##;
		## drawLine # bottom # front ##;
	}

	// Draws entities common to all states.
	function drawCommon() {
		// Draw box around world.
		## drawLine # [0.0, 0.0] # MainScene.farTopLeft ##;
		## drawLine # [X_RES, 0.0] # MainScene.farTopRight ##;
		## drawLine # [0.0, Y_RES] # MainScene.farBottomLeft ##;
		## drawLine # [X_RES, Y_RES] # MainScene.farBottomRight ##;
		## drawLine # MainScene.farTopLeft # MainScene.farTopRight ##;
		## drawLine # MainScene.farTopRight # MainScene.farBottomRight ##;
		## drawLine # MainScene.farBottomRight # MainScene.farBottomLeft ##;
		## drawLine # MainScene.farBottomLeft # MainScene.farTopLeft ##;

		// Draw lasers.
		for (pos : this.lasers) {
			start = ## project # pos ##;
			end = ## project # [pos[0], pos[1], pos[2] + LASER_LENGTH] ##;
			## drawLine # start # end ##;
		}

		// Draw enemies.
		for (enemy : this.enemies) {
			pos = enemy.pos;
			theta = this.timeInState * enemy.omega;
			cosT = Math.cos(theta);
			sinT = Math.sin(theta);
			cosT90 = Math.cos(theta + 0.5 * Math.PI);
			sinT90 = Math.sin(theta + 0.5 * Math.PI);
			left = ## project # [pos[0] - ENEMY_RADIUS * cosT, pos[1] - ENEMY_RADIUS * sinT, pos[2]] ##;
			right = ## project # [pos[0] + ENEMY_RADIUS * cosT, pos[1] + ENEMY_RADIUS * sinT, pos[2]] ##;
			top = ## project # [pos[0] + ENEMY_RADIUS * cosT90, pos[1] + ENEMY_RADIUS * sinT90, pos[2]] ##;
			bottom = ## project # [pos[0] - ENEMY_RADIUS * cosT90, pos[1] - ENEMY_RADIUS * sinT90, pos[2]] ##;
			front = ## project # [pos[0], pos[1], pos[2] - ENEMY_HALF_LENGTH] ##;
			back = ## project # [pos[0], pos[1], pos[2] + ENEMY_HALF_LENGTH] ##;
			## drawLine # left # top ##;
			## drawLine # top # right ##;
			## drawLine # right # bottom ##;
			## drawLine # bottom # left ##;
			## drawLine # left # front ##;
			## drawLine # top # front ##;
			## drawLine # right # front ##;
			## drawLine # bottom # front ##;
			## drawLine # left # back ##;
			## drawLine # top # back ##;
			## drawLine # right # back ##;
			## drawLine # bottom # back ##;
		}

		// Draw debris.
		for (debris : this.debris) {
			pos = debris.pos;
			theta = this.timeInState * debris.omega;
			radius = DEBRIS_RADIUS * debris.lifetime / DEBRIS_MAX_LIFETIME;
			right = ## project #
				[ pos[0] + radius * Math.cos(theta)
				, pos[1] + radius * Math.sin(theta)
				, pos[2]
				] ##;
			topLeft = ## project #
				[ pos[0] + radius * Math.cos(theta + ONE_THIRD_TAU)
				, pos[1] + radius * Math.sin(theta + ONE_THIRD_TAU)
				, pos[2]
				] ##;
			bottomLeft = ## project #
				[ pos[0] + radius * Math.cos(theta + TWO_THIRDS_TAU)
				, pos[1] + radius * Math.sin(theta + TWO_THIRDS_TAU)
				, pos[2]
				] ##;
			## drawLine # right # topLeft ##;
			## drawLine # topLeft # bottomLeft ##;
			## drawLine # bottomLeft # right ##;
		}
	}

	function drawHUD() {
		// Draw score.
		this.scoreText.draw(0.5 * X_RES - this.scoreText.width, 0);

		// Draw lives.
		for (i = 0; i < this.lives; ++i) {
			MainScene.heart.draw
				( 0.5 * X_RES + HEART_LEFT_PAD + i * (HEART_LEFT_PAD + MainScene.heart.width)
				, HEART_TOP_PAD
				);
		}
	}

	function render() {
		Graphics2D.Draw.fill(0, 0, 0);

		switch (this.state) {
			case MOVEMENT_HELP_STATE:
				this.drawShip();
				MainScene.movementHelp.draw
					( 0.5 * (X_RES - MainScene.movementHelp.width)
					, 0.75 * Y_RES - 0.5 * MainScene.movementHelp.height
					);
				break;
			case TITLE_STATE:
				this.drawShip();
				break;
			case PLAYING_STATE:
				this.drawShip();
				this.drawHUD();
				break;
			case GAME_OVER_STATE:
				this.drawHUD();
				break;
		}
		this.drawCommon();
	}
}
